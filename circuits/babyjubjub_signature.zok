//import "ecc/edwardsScalarMult" as scalarMult;
import "ecc/edwardsAdd" as add;
import "utils/pack/bool/nonStrictUnpack256" as unpack256bool;
import "ecc/edwardsOnCurve" as onCurve;
import "ecc/edwardsOrderCheck" as orderCheck;
from "ecc/babyjubjubParams" import BabyJubJubParams;
import "hashes/poseidon/poseidon" as poseidon;

// Debug
import "utils/pack/bool/pack256" as pack256bool;

from "./types" import Tx, Signature;

// Function that implements scalar multiplication for a fixed base point
// Curve parameters are defined with the last argument
// The exponent is hard-coded to a 256bit scalar, hence we allow wrapping around the group for certain
// curve parameters.
// Note that the exponent array is not check to be boolean in this gadget
// Reference: https://github.com/zcash-hackworks/sapling-crypto/blob/master/src/jubjub/fs.rs#L555
def scalarMult<BITS>(bool[BITS] exponent, field[2] pt, BabyJubJubParams context) -> field[2] {
    field[2] infinity = context.INFINITY;

    field[2] mut doubledP = pt;
    field[2] mut accumulatedP = infinity;

    for u32 i in 0..BITS {
        u32 j = (BITS - 1) - i;
        field[2] candidateP = add(accumulatedP, doubledP, context);
        accumulatedP = exponent[j] ? candidateP : accumulatedP;
        doubledP = add(doubledP, doubledP, context);
    }

    assert(onCurve(accumulatedP, context));
    return accumulatedP;
}

/// Verifies an EdDSA Signature.
///
/// Checks the correctness of a given EdDSA Signature (R,S) for the provided
/// public key A and message (M0, M1).
/// This python repo provides the tooling for creating valid signatures:
/// https://github.com/Zokrates/pycrypto
///
/// For more information see:
/// https://en.wikipedia.org/wiki/EdDSA
/// https://eprint.iacr.org/2015/677.pdf
///
/// Arguments:
///    R: Curve point. Hidden version of the per-message nonce.
///    S: Field element. Signature to be verified.
///    A: Curve point. Public part of the key used to create S.
///    M0: 256bit array. First 256bits of the message used to create S  .
///    M1: 256bit array. Trailing 256bits of the message used to create S  .
///    context: Curve parameters used to create S.
///
/// Returns:
///     Return true for S being a valid EdDSA Signature, false otherwise.
def main(Signature sig) -> bool {
	BabyJubJubParams context = BabyJubJubParams {
		// Order of the curve for reference: 21888242871839275222246405745257275088614511777268538073601725287587578984328
		JUBJUB_C: 8, // Cofactor
		JUBJUB_A: 168700, // Coefficient A
		JUBJUB_D: 168696, // Coefficient D

		// Montgomery parameters
		MONT_A: 168698,
		MONT_B: 1,

		// Point at infinity
		INFINITY: [0, 1],

		// Base Point
		Gu: 5299619240641551281634865583518297030282874472190772894086521144482721001553,
		Gv: 16950150798460657717958625567821834550301663161624707787222815936182638968203
	};
    field[2] G = [context.Gu, context.Gv];

    // Check if R is on curve and if it is not in a small subgroup. A is public input and can be checked offline
    assert(onCurve([sig.r.x, sig.r.y], context)); // throws if R is not on curve
    assert(orderCheck([sig.r.x, sig.r.y], context));

	field po = poseidon::<5>([sig.r.x, sig.r.y, sig.a.x, sig.a.y, sig.m]);
	bool[257] hRAM = [...unpack256bool(po)[2..], false, false, false];
	//bool[256] hRAM = unpack256bool(po * 8);
	/*
	bool[256] un = unpack256bool(po);
	bool[256] mut hRAM = [false; 256];
	for u32 i in 0..253 {
		hRAM[i] = un[i + 3];
	}
	*/

    bool[256] sBits = unpack256bool(sig.s);
    field[2] lhs = scalarMult(sBits, G, context);

    field[2] AhRAM = scalarMult(hRAM, [sig.a.x, sig.a.y], context);
    field[2] rhs = add([sig.r.x, sig.r.y], AhRAM, context);

    bool out = lhs == rhs;
    assert(out);

	return true;
}
